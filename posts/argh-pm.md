# Argh-P-M â€“ Dissecting the RPM file format

As the first actual content on my new blog, let me tell you the story of how I went absolutely crazy.

On my private systems, I ship configuration as system packages. Every distribution has their own tooling and process for
building these packages, but I eventually grew tired of all the ceremony involved in it, and wrote [my own system
package compiler](https://github.com/holocm/holo-build). Since I'm using Arch Linux everywhere, the first version
generated only Pacman packages, but I was determined to make it truly cross-distribution. The first step was support for
Debian packages, which I implemented in a mere two evenings (one for understanding the format, one for writing the
generator).

Next to dpkg, the other widely deployed package format is RPM, so I set out to add support for RPM as well. If I could
write the Debian generator in two days, then surely RPM support wouldn't take that long, either. Little did I know that
I was embarking on a multi-month endeavor. To add insult to injury, I stubbornly refused to add dependencies and use
existing tooling (i.e., the `rpm-build(1)` command). I wanted to serialize the format directly from my own code, like I
did for Pacman and Debian packages.

## How to get a package format right

Before we get to RPM, let's have a brief look at how a sane package format looks like. I always use the package for
`tree(1)` as a sample because it's a small package with just one executable and maybe a manpage that's available on
every distribution.

```
$ file -kr tree_1.7.0-3_amd64.deb
tree_1.7.0-3_amd64.deb: Debian binary package (format 2.0)
- current ar archive
- archive file
- data
```

`file` tells us that a Debian package is actually an [`ar` archive](https://en.wikipedia.org/wiki/Ar_(Unix)). Let's
unpack it.

```
$ ar x tree_1.7.0-3_amd64.deb
control.tar.gz  data.tar.xz  debian-binary  tree_1.7.0-3_amd64.deb

$ cat debian-binary
2.0

$ tar tf control.tar.gz
./
./control
./md5sums

$ tar tf data.tar.xz | grep -v '/$'
./usr/bin/tree
./usr/share/doc/tree/copyright
./usr/share/doc/tree/TODO
./usr/share/doc/tree/changelog.Debian.gz
./usr/share/doc/tree/changelog.gz
./usr/share/doc/tree/README.gz
./usr/share/man/man1/tree.1.gz
```

The `ar` archive contains three files:

* `debian-binary` establishes that the package conforms to the dpkg 2.0 format.
* `control.tar.gz` contains metadata: the package name, description, dependencies to other packages, checksums, and so on.
* `data.tar.xz` contains the actual files that will be unpacked onto the root filesystem when the package is installed.

The separation into two different subarchives is really clever: The actual application data can be compressed very
tightly with `xz`, to minimize disk space and network usage on the package mirror. The metadata is compressed with `gz`
only, so it can be accessed quickly when a repository index is being created. The files in `control.tar.gz` are simple
plain text files, so you can process them comfortably even from shell scripts:

```
$ tar Oxf control.tar.gz ./control | head
Package: tree
Version: 1.7.0-3
Architecture: amd64
Maintainer: Florian Ernst <florian@debian.org>
Installed-Size: 100
Depends: libc6 (>= 2.14)
Section: utils
Priority: optional
Homepage: http://mama.indstate.edu/users/ice/tree/
Description: displays an indented directory tree, in color
```

So much for dpkg. Pacman packages (for Arch Linux) don't look too different, but they only have a single archive for
everything, as opposed to the two tarballs inside a Debian package. Metadata is placed in the package as files with
special names in the root directory:

```
$ tar tf tree-1.7.0-1-x86_64.pkg.tar.xz
.PKGINFO
.MTREE
usr/
usr/bin/
usr/share/
usr/share/man/
usr/share/man/man1/
usr/share/man/man1/tree.1.gz
usr/bin/tree

$ tar Oxf tree-1.7.0-1-x86_64.pkg.tar.xz .PKGINFO | head
# Generated by makepkg 4.1.2
# using fakeroot version 1.20
# Thu Apr 24 18:18:51 UTC 2014
pkgname = tree
pkgver = 1.7.0-1
pkgdesc = A directory listing program displaying a depth indented list of files
url = http://mama.indstate.edu/users/ice/tree/
builddate = 1398363531
packager = Giovanni Scafora <giovanni@archlinux.org>
size = 78848
```

The Debian approach with multiple archives is preferable, though, because you can decompress the metadata quicker. With
the single archive approach of Pacman, it might be that the metadata is put at the end of the tarball. You would then
have to decompress the whole archive (possibly over a gigabyte) to get at a few kilobytes of metadata.

By the way: Before we get to RPM, let me take a moment to acknowledge the outstanding
[Debian Policy Manual](https://www.debian.org/doc/debian-policy/index.html), which specifies every last bit of the
dpkg format in a relevant and concise manner. Kudos to everyone who contributed to it.

## Cracking open an RPM file

Now let's grab an RPM from [rpmfind.net](https://rpmfind.net) and see what's in it.

```
$ file -kr tree-1.7.0-7.fc26.x86_64.rpm
tree-1.7.0-7.fc26.x86_64.rpm: RPM v3.0 bin i386/x86_64
- data
```

`file` cannot tell us anything except that the RPM file actually is an RPM file. It appears that RPM is really an
original file format and not built on top of an existing format such as `ar` (for dpkg) or `tar` (for Pacman). However,
there is a [formal specification][lsb] of the RPM format, as part of the Linux Standard Base. Let's see what we got
there.

[lsb]: http://refspecs.linux-foundation.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/pkgformat.html

> An RPM format file consists of 4 sections, the Lead, Signature, Header, and the Payload. All values are stored in
> network byte order.

Two sentences in, and I already don't like where this is going. Let's start at the top. The lead section is defined by
its C declaration:

```c
struct rpmlead {
    unsigned char magic[4];
    unsigned char major, minor;
    short type;
    short archnum;
    char name[66];
    short osnum;
    short signature_type;
    char reserved[16];
};
```

Here's how it looks in my sample. I'm highlighting the fields in alternating colors for your viewing pleasure:

<pre><code>$ xxd tree-1.7.0-7.fc26.x86_64.rpm | head -n6
00000000: <span style="color:green">edab eedb</span> <span style="color:blue">03</span><span style="color:green">00</span> <span style="color:blue">0000</span> <span style="color:green">0001</span> <span style="color:blue">7472 6565 2d31</span>  ..........tree-1
00000010: <span style="color:blue">2e37 2e30 2d37 2e66 6332 3600 0000 0000</span>  .7.0-7.fc26.....
00000020: <span style="color:blue">0000 0000 0000 0000 0000 0000 0000 0000</span>  ................
00000030: <span style="color:blue">0000 0000 0000 0000 0000 0000 0000 0000</span>  ................
00000040: <span style="color:blue">0000 0000 0000 0000 0000 0000</span> <span style="color:green">0001</span> <span style="color:blue">0005</span>  ................
00000050: <span style="color:green">0000 0000 0000 0000 0000 0000 0000 0000</span>  ................
</code></pre>

The spec tells us what everything means:
* `major, minor = 3, 0` refers to the package format version 3.0.
* `type = 0` makes it a binary package (`1` would be a source package).
* `archnum = 1` is x86. You might interject, "but it's actually an x86\_64 package!" To which RPM replies, "32-bit,
  64-bit... tomayto, tomahto."
* `name` is misnamed and should be called `name_and_version_and_release` because these three things are mashed together
  in a single field.
* `osnum = 1` indicates Linux.
* `signature_type = 5` means "Yes" as far as I can tell.

If you happen to have RPM installed, you can check out `/usr/lib/rpm/rpmrc` for a list of acceptable values for
`archnum` and `osnum`. Look for lines starting with `arch_canon` and `os_canon`. This file comes in really handy if you
ever need a list of every single architecture and Unix-like OS that has ever existed, anywhere.

## Headers inside headers

According to [a document on the rpm-org website][rpm-org], the lead section used to be the only place in an RPM file for
metadata. But when you take a second look, you will notice that a lot of very important metadata is missing in it. There
is no way to specify dependencies between packages, a feature so fundamental to system package managers that I wonder
how RPM ever got by without it.

[rpm-org]: http://www.rpm.org/max-rpm/ch-rpm-file-format.html

The RPM developers decided to ditch the lead section, leaving it in the file format only for the magic number and for
backwards compatibility. What happened next is an effect so common in software development that it has its own name: the
*second-system effect* or *second-system syndrome*. From Wikipedia:

> The second-system effect proposes that, when an architect designs a second system, it is the most dangerous system
> they will ever design, because they will tend to incorporate all of the additions they originally did not add to the
> first system due to inherent time constraints. Thus, when embarking on a second system, an engineer should be mindful
> that they are susceptible to over-engineering it.

And that's exactly what happened. While Debian and Pacman packages use simple text files with `key: value` lines for
their metadata, the RPM spec includes a custom binary format for a key-value database. Both the signature section and
header section follow this format. My favorite part of all this is that because of this, an RPM file actually has
**five** headers:

* the lead section (deprecated)
* the signature section
    * the header of its key-value database
* the header section
    * the header of its key-value database

The key-value database's header looks like this:

```c
struct rpmheader {
    unsigned char magic[4];    // must be "\216\255\350\001"
    unsigned char reserved[4]; // must be "\0\0\0\0"
    int nindex;                // number of index records
    int hsize;                 // size of storage area for data
};
```

After that comes one *index record* for each key-value pair, followed by the storage area. The index records look like
this:

```c
struct rpmhdrindex {
    int tag;    // the key
    int type;   // data type
    int offset; // where to find the data in the storage area
    int count;  // how many data items are stored in this key
};
```

There are a few things to notice here:

- The keys (or *tags* on RPM parlance) are numbers rather than strings. The `<rpm/rpmtag.h>` header has an enum with all
  acceptable values, but please consider the environment before trying to print it. RPM 4.13 defines 318 tags (302 for
  the header section and 16 for the signature section). The equivalent `control` file in a Debian package has 29 fields.

- Acceptable data types include strings, binary data, and integers of various sizes. For strings and integers, multiple
  values can be stored in one tag (like an array). A unique feature of RPM is *translatable strings*: These are lists of
  strings, where each item corresponds to a locale string listed in the `RPMTAG_HDRI18NTABLE` tag. Nobody seems to use
  this localization function, though. In all the samples that I examined, `RPMTAG_HDRI18NTABLE` only contained one
  locale, `C`, and every translatable string contained just the original English string.

- All the fields that count stuff (`rpmheader.nindex`, `rpmheader.hsize` and `rpmhdrindex.count`) are 32 bit wide and
  thus can count up to 4 billion. My code contains a [witty comment][gh1] about the designers "planning ahead".

[gh1]: https://github.com/holocm/holo-build/blob/v1.4/src/dump-package/impl/rpm.go#L113

## The header section

With the storage format out of the way, let's have a look at what data is actually stored in there. I'll use the output
of [dump-package](https://github.com/holocm/holo-build/tree/v1.4/src/dump-package), a little inspection tool that I
wrote during this endeavor. It dumps the binary data structures into a nice and readable format. Unfortunately, the data
in the structures is not nearly as readable.

```
tag 1000 (NAME): length 1
    string: tree
tag 1001 (VERSION): length 1
    string: 1.7.0
tag 1002 (RELEASE): length 1
    string: 7.fc26
tag 1004 (SUMMARY): length 1
    translatable string: File system tree viewer
tag 1005 (DESCRIPTION): length 1
    translatable string: The tree utility recursively displays the contents of directories in a
    tree-like format.  Tree is basically a UNIX port of the DOS tree
    utility.
tag 1009 (SIZE): length 1
    int32: 99355
tag 1014 (LICENSE): length 1
    string: GPLv2+
tag 1021 (OS): length 1
    string: linux
tag 1022 (ARCH): length 1
    string: x86_64
```

So far, so unsurprising. Some stuff is duplicated with the lead section (which is okay since it is considered
deprecated). Name, version and release are cleanly separated.

```
tag 1010 (DISTRIBUTION): length 1
    string: Fedora Project
tag 1011 (VENDOR): length 1
    string: Fedora Project
tag 1015 (PACKAGER): length 1
    string: Fedora Project
```

From the department of redundancy department.

```
tag 1016 (GROUP): length 1
    translatable string: Applications/File
```

The `RPMTAG_GROUP` is listed in the LSB spec as "required", but it doesn't say anything about acceptable values. The
documentation for openSUSE has [such a list][suse-group], but the Fedora Project Wiki says that ["the Group: tag is
unnecessary"][fedora-group].

[suse-group]: https://en.opensuse.org/openSUSE:Package_group_guidelines
[fedora-group]: https://fedoraproject.org/wiki/Packaging:Guidelines?rd=Packaging/Guidelines#Tags_and_sections

```
tag 1020 (URL): length 1
    string: http://mama.indstate.edu/users/ice/tree/
```

The spec lists two tags with URLs, with incredibly helpful descriptions:

> `RPMTAG_URL` -- Generic package information URL <br>
> `RPMTAG_DISTURL` -- URL for package

Luckily, they're both optional, so I don't need to care.

```
tag 1006 (BUILDTIME): length 1
    int32: 1472740798
tag 1007 (BUILDHOST): length 1
    string: buildvm-23.phx2.fedoraproject.org
tag 1044 (SOURCERPM): length 1
    string: tree-1.7.0-7.fc26.src.rpm
tag 1064 (RPMVERSION): length 1
    string: 4.13.0-rc1
tag 1122 (OPTFLAGS): length 1
    string: -O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic
tag 1132 (PLATFORM): length 1
    string: x86_64-redhat-linux-gnu
```

With over 300 tags, it's no surprise that the usefulness of many of these tags is debatable, especially considering the
recent push towards [reproducible packages](https://reproducible.debian.net).

The usefulness curve quickly goes downhill:

```
tag 1124 (PAYLOADFORMAT): length 1
    string: cpio
tag 1125 (PAYLOADCOMPRESSOR): length 1
    string: xz
tag 1126 (PAYLOADFLAGS): length 1
    string: 2
```

This tells us that the payload is a CPIO archive, compressed with XZ. You know, because there
is [no way at all to infer this from the payload itself][magic]. Fun fact: This part of the dump shows that this Fedora
RPM is actually *not LSB-compliant*. The LSB spec states clearly that the payload compressor must be `gzip`, and that
`RPMTAG_PAYLOADFLAGS` must be `9`. If you're wondering what payload flags are: "This tag indicates the compression level
used for the Payload." We've reached negative usefulness values now.

[magic]: https://en.wikipedia.org/wiki/Magic_number_(programming)

By now, you might be wondering: RPM files may have sections, with two sections having their own headers that define a
key-value database, with several keys of dubious utility. But do you have anything in store for a true connaisseur of
byzantine complexity? Well, say no more!

```
tag 1080 (CHANGELOGTIME): length 70
    int32: 1472731200
    int32: 1454673600
    int32: 1434715200
    [...]
tag 1081 (CHANGELOGNAME): length 70
    string: Kamil Dudka <kdudka@redhat.com> - 1.7.0-7
    string: Fedora Release Engineering <releng@fedoraproject.org> - 1.7.0-6
    string: Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 1.7.0-5
    [...]
tag 1082 (CHANGELOGTEXT): length 70
    string: - drop a non-upstream patch that disabled color output by default (#1284657)
    string: - Rebuilt for https://fedoraproject.org/wiki/Fedora_24_Mass_Rebuild
    string: - Rebuilt for https://fedoraproject.org/wiki/Fedora_23_Mass_Rebuild
```

A `changelog.txt` is for filthy peasants! Real men store their changelog in a structured key-value database!

But wait, there's more!

<!-- TODO: file attributes, package relations; signature section; payload -->

<!-- TODO: note to self - don't forget about the funny enums in rpmlib.h -->

